#!/bin/bash

################################################################################
# Copyright (c) 2012      Los Alamos National Security, LLC.
#                         All rights reserved.
#
# This program was prepared by Los Alamos National Security, LLC at Los Alamos
# National Laboratory (LANL) under contract No. DE-AC52-06NA25396 with the U.S.
# Department of Energy (DOE). All rights in the program are reserved by the DOE
# and Los Alamos National Security, LLC. Permission is granted to the public to
# copy and use this software without charge, provided that this Notice and any
# statement of authorship are reproduced on all copies. Neither the U.S.
# Government nor LANS makes any warranty, express or implied, or assumes any
# liability or responsibility for the use of this software.
################################################################################

# author: samuel k. gutierrez
# last updated: Fri Jun 29 09:03:07 MDT 2012

################################################################################
################################################################################
#         ONLY TESTED ON RR-LIKE SYSTEMS WITH PBS AND OPEN MPI 1.4.3!          #
################################################################################
################################################################################

declare -r PROG_NAME="rr-job-prep"
declare -r PROG_VER="0.1"
declare -r CRUNCH_NAME="crunch-hang"
declare -r ALL_NODES_FN="ALL"
declare -r SUBSET_NODES_FN="SUB"
declare -r SMGC_OUT_FN="OUT"

# items to be run on exit
declare -a on_exit_items

# this will eventually be set to a real value, but set to a safe default
tmp_base="/tmp"
# job id
jobid="unknown"
# pid of killer - start with something bogus and relatively harmless
killer_pid=$$

# in seconds
#declare -r KILL_TIMEOUT=300
declare -r KILL_TIMEOUT=4

################################################################################
################################################################################
# exit/cleanup code
################################################################################
################################################################################
function on_exit()
{
    for i in "${on_exit_items[@]}"; do
        #echo "on_exit: $i"
        eval "$i" 2>&1 > /dev/null
    done
}

################################################################################
function add_on_exit()
{
    local n=${#on_exit_items[*]}
    on_exit_items[$n]="$*"
    if [[ $n -eq 0 ]]; then
        #echo "setting trap"
        trap on_exit EXIT
    fi
}

################################################################################
function usage()
{
cat << EOF
Usage:
    $PROG_NAME [OPTION] [/PATH/TO/SUPERMAGIC] [/PATH/TO/CRUNCH-HANG] [MIN PES]
Options:
    -v|--version
    -h|--help
About:
    $PROG_NAME does stuff... 
EOF
}

################################################################################
function run_and_pray()
{
    ( mpirun --hostfile "$tmp_base/$SUBSET_NODES_FN" \
    "$1" -t small_all_to_all_ptp 2>&1 | \
    tee "$tmp_base/$SMGC_OUT_FN" 2>&1 > /dev/null )&
    cmd_pid=$!

    # setup the killer
    ( sleep $KILL_TIMEOUT && \
      kill -9 $cmd_pid )&
    killer_pid=$!

    wait $cmd_pid &> /dev/null
    wait_status=$?

    if [[ $wait_status -ne 0 ]]; then 
        echo "### RUN TIMEOUT EXCEEDED. this may mean we can't launch mpi jobs."
        echo "### please contact the system administrators."
        echo "### JOBID: $jobid"
        # not much else we can do here... well, maybe that's not true, but it
        # is a little harder to deal with
        exit 1;
    else
        # "normal" exit, so clean up - we still don't know if things worked.
        disown $killer_pid
        kill $killer_pid 2>&1 > /dev/null
    fi

    local crunch_out=`$2 "$tmp_base/$SMGC_OUT_FN"`

    if [[ "x$crunch_out" == "x### NO HANG ###" ]]; then
        echo "### successful run - found a good set!"
        return 0;
    else
        # no love. we launched, but the job hung in messaging :-(.  update the
        # hostfile and return 1 - indicating that we failed to find a good set.
        return 1;
    fi
}

################################################################################
function find_good_node_set()
{
    echo "### starting - cross your fingers ###"
    echo
    run_and_pray "$1" "$2" "$3"
    while [[ $? == 1 ]]; do
        echo "### trying another set..."
        run_and_pray "$1" "$2" "$3"
        # we don't want to overwhelm the system, so take a little break
        sleep 5
    done
}

################################################################################
function have_jobid()
{
    if [[ "x$PBS_JOBID" == "x" ]]; then
        echo 0
    else
        echo 1
    fi
}

################################################################################
function hello()
{
cat << EOF
### $PROG_NAME $PROG_VER ###
EOF
}

################################################################################
function init()
{
    echo "# starting init..."
    if [[ `have_jobid` -eq 1 ]]; then
        jobid="$PBS_JOBID"
    else
        echo "cannot determine job id"
        exit 1;
    fi
    tmp_base=`mktemp -d -t SMGCXXXX`
    echo "# timeout: $KILL_TIMEOUT s"
    echo "# temp directory: $tmp_base"
    echo "# copying $PBS_NODEFILE file to $tmp_base"
    # save a copy of the full list of nodes and start with a full set
    cp $PBS_NODEFILE "$tmp_base/$ALL_NODES_FN" && \
    cp "$tmp_base/$ALL_NODES_FN" "$tmp_base/$SUBSET_NODES_FN"
    if [[ $? != 0 ]]; then
        echo "cp failure!"
        exit 1;
    else
        # add cleanup code
        add_on_exit rm -f "$tmp_base/$ALL_NODES_FN"
        add_on_exit rm -f "$tmp_base/$SUBSET_NODES_FN"
        add_on_exit rm -f "$tmp_base/$SMGC_OUT_FN"
        add_on_exit rmdir "$tmp_base"
        add_on_exit killall -q -9 mpirun
        add_on_exit killall -q -9 supermagic
    fi
}

################################################################################
# $1: path to supermagic
# $2: path to crunch-hang
# will exit with status 1 if app/env prerequisites are not met.
function sanity()
{
    local the_base=$(basename "$1")
    # check for mpirun
    type -p "mpirun" 2>&1 > /dev/null
    local tstat=$?
    if [[ $tstat -eq 1 ]]; then
        echo "mpirun not found. cannot continue."
        exit 1;
    fi
    # check for supermagic - at some point provide better detection
    if [[ "$the_base" == "supermagic" ]]; then
        # okay, the name is fine, but can we exec the thing?
        if [[ ! -x "$1" ]]; then
            echo "cannot continue: cannot execute "$1""
            exit 1;
        fi
    else
        echo -e "could not find supermagic:\n"$1" is not supermagic."
        exit 1;
    fi
    # check crunch-hang
    if [[ -x "$2" ]]; then
        local out_str=`"$2" --version`
        local cname=`echo "$out_str" | cut -f 1 -d ' '`
        if [[ "x$cname" != "x$CRUNCH_NAME" ]]; then
            echo -e "valid $CRUNCH_NAME not found:\n"$2" cannot be used."
            exit 1;
        fi
    else
        echo -e "could not execute crunch-hang:\n"$2"."
        exit 1;
    fi
    # is PBS_NODEFILE set? we need this to construct a node list.
    if [[ "x$PBS_NODEFILE" == "x" ]]; then
        echo "PBS_NODEFILE not set. this environment used in "$PROG_NAME"."
        exit 1;
    fi
}

################################################################################
for i in $*; do
    case $1 in
        -h|--help)
            usage
            exit 0;
            ;;
        -v|--version)
            echo "$PROG_VER"
            exit 0;
            ;;
        --)
            shift
            break
            ;;
        -?|--?)
            echo "unknown option: \"$i\""
            exit 1;
            ;;
    esac
done

if [[ $# != 3 ]]; then
    usage
    exit 1;
else
    hello
    init
    sanity "$1" "$2"
    # if we are here, let the games begin...
    find_good_node_set "$1" "$2" "$3"
    exit $?;
fi
